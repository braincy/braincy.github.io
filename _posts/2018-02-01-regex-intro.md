---
layout: post
title: 正则表达式常用语法
date: 2018-02-01 16:59:20
tags: [正则]
categories: python
mathjax: true
---

* content
{:toc}

本文对python中 *正则表达式* 的基本用法进行介绍。




## 常用语法

### 特殊字符

| 特殊字符 | 描述 |
| :------: | :------ |
| \$| 匹配输入字符串的结尾位置。|
| ()| 标记一个子表达式的开始和结束位置。|
| * | 匹配前面的子表达式零次或多次。|
| + | 匹配前面的子表达式一次或多次。|
| . | 匹配除换行符 \n 之外的任何单字符。|
| [ | 标记一个中括号表达式的开始。|
| ? | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。|
| \ | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。|
| ^ | 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。|
| { | 标记限定符表达式的开始。|
| &#124; | 指明两项之间的一个选择。|

### 限定符

| 字符 | 描述 |
| :--: | :--- |
| * | 匹配前面的子表达式零次或多次。\* 等价于 {0,}。|
| +    | 匹配前面的子表达式一次或多次。+ 等价于 {1,}。|
| ? | 匹配前面的子表达式零次或一次。? 等价于 {0,1}。|
| {n} |    n 是一个非负整数。匹配确定的 n 次。|
| {n,} | n 是一个非负整数。至少匹配 n 次。|
| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。请注意在逗号和两个数之间不能有空格。|


### 定位符

| 字符 | 描述 |
| :--: | :--- |
| ^ | 匹配输入字符串开始的位置。|
| $    | 匹配输入字符串结尾的位置。|
| \b| 匹配一个字边界，即字与空格间的位置。|
| \B| 非字边界匹配。|

## Python中使用正则表达式

Python提供 `re` 模块，包含所有正则表达式的功能。需要注意的是我们最好使用Python中的 `r` 前缀，否则就需要通过 `\` 进行转义。

### 判断是否匹配成功
```python
test = '用户输入的字符串'
if re.match(r'正则表达式', test):
    print 'ok'
else:
    print 'failed'
```

### 分组

除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用 `()` 表示的就是要提取的分组（Group）。比如：`^(\d{3})-(\d{3,8})$` 分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：
```python
import re
m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
print m
print m.group(0)
print m.group(1)
print m.group(2)
```
> <\_sre.SRE\_Match object at 0x7fc4cd8a7718>
> 010-12345
> 010
> 12345

如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来。

*注意到 $group(0)$ 永远是原始字符串，$group(i)(i\geq 1)$ 表示第 $i$ 个子串。*

### 贪婪匹配

最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：
```python
import re
print re.match(r'^(\d+)(0*)$', '102300').groups()
```
> ('102300', '')

由于 `\d+` 采用贪婪匹配，直接把后面的0全部匹配了，结果 `0*` 只能匹配空字符串了。

必须让 `\d+` 采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个 `?` 就可以让 `\d+` 采用非贪婪匹配：
```python
import re
print re.match(r'^(\d+?)(0*)$', '102300').groups()
```
> ('1023', '00')

### 编译

在Python中使用正则表达式时，re模块内部会干两件事情：

* 编译正则表达式，如果正则表达式的字符串本身不合法，会报错
* 用编译后的正则表达式去匹配字符串

如果一个正则表达式要重复使用几千次，出于效率的考虑，可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：
```python
import re
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
print re_telephone.match('010-12345').groups()
print re_telephone.match('010-8086').groups()
```
> ('010', '12345')
> ('010', '8086')

这里只记录了正则表达式的基本用法，更多用法待日后补充。
