---
layout: post
title: Python3基础与进阶
date: 2018-06-05 19:59:02
tags: [Python]
categories: Python
mathjax: true
---

* content
{:toc}

本文对为Python的入门笔记，包含一些常见误区的解释以及代码风格的建议。




## 包、模块、函数与变量作用域
### 包内\_\_init\_\_.py的作用
导入包或者包内模块的时候自动运行且第一个运行。主要应用在以下两个场景：

* 限制包内模块的导入，\_\_all\_\_ = [模块名, ...]
* 批量导入库（比如sys）

### 包与模块的几个注意点
* 包和模块不会被重复导入。
* 避免循环导入，不管是直接循环还是间接循环。解决方法：打开循环，取消最后一个文件的import。
* 执行导入模块语句时，会执行被导入模块的所有代码。

### 模块内置变量
> 1. \_\_name\_\_：模块的完整名字，具体为`命名空间.模块名`
> 2. \_\_package\_\_：模块所在的包
> 3. \_\_file\_\_：文件所在的物理路径
> 4. \_\_doc\_\_：模块内的注释说明内容

*`dir()` 可以返回当前模块所有变量， `dir(函数名/类名)` 返回指定函数/类的所有变量。*

### 入口文件与普通模块内置变量的区别
* 入口文件的\_\_name\_\_为\_\_main\_\_。
* 入口文件的\_\_package\_\_为None，因为作为顶级文件，不属于任何包。
* 入口文件的\_\_file\_\_与执行命令所在的目录有关。

### \_\_name\_\_的经典应用
```python
if __name__ == '__main__':
    pass
```
这行代码可以判断当前模块是否为入口文件。其功能为：让这个脚本既可以作为一个普通的模块被导入到其他模块，也可以作为可执行模块。

### -m参数的作用
执行命令：python -m 命名空间.模块模块名
作用：将可执行文件当做普通模块调用

### 相对导入和绝对导入
要弄清python的导入就一定要明确顶级包的概念。下面对顶级包以及python的两种导入方式进行详细介绍。
> 顶级包： 顶级包与入口文件的层级有关，与入口文件同级的就是顶级包。
> 绝对导入：绝对导入必须从顶级包开始，即通过绝对路径导入。
> 相对导入：相对路径能找到相应模块的原因是它能够根据\_\_name\_\_定位，但对于入口文件，它的名字已被强行改为\_\_name\_\_，故入口文件一般只使用绝对路径。

*注：包的导入不能超过顶级包。*

## Python函数
### 函数定义注意点
定义函数或变量时，尽量避免和Python的内置函数或变量同名，避免导致递归调用等错误。

*注：可以通过下面的代码定义最大的递归层数：*
```python
import sys
sys.setrecursionlimit(自定义递归层数)
```

### 函数的参数
* 必须参数：函数的参数列表中定义的必须赋值的参数（必须放在参数列表的前面）。
* 关键字参数：可以在函数调用时明确指出实参是传给哪个形参的，不一定要按照形参顺序。
*注：必须参数和关键字参数的区别在于函数调用上而不是定义上*
* 默认参数：可以在定义行直接给形参赋值，该形参称为默认参数。
*所有非默认参数必须在所有默认参数前*
* 可变参数：在形参前加 `*`，Python会自动把可变参数列表所对应的实参组装成一个tuple。
*注：调用时直接传元祖，则返回结果是一个二维元祖；若不想形成二维元祖，函数调用时可以使用 `*`，它将把元祖里的元素平铺传递给函数。*
* 关键字参数：在形参前加 `**`，Python会自动把可变参数列表所对应的实参组装成一个dict。

*函数参数的顺序：必须参数、可变参数、默认参数，当需要更改默认参数值时，必须用关键字参数给默认参数赋值。（不建议把函数参数类别设计如此复杂）*

### 变量作用域
在Python中，函数外的变量是全局变量，可以被多个函数所引用，作用于整个应用程序。

函数内部定义的变量成为局部变量，局部变量是相对的。

在Python中，for循环不能形成一个块级作用域，即循环内定义的变量与函数内定义的变量属于同一级别，可以在循环外使用。

*注：作用域具有链式特性，逐级寻找。Python中最小作用域是函数。*
#### global关键字
主要用于将函数内部的局部变量暴露出来，可以由外部函数或者其他模块（import）进行引用。
```python
def demo():
    global c
    c = 1
demo()
print(c)
```
*注：其他模块使用该模块，该模块的函数必须得先调用，如 `demo()`。*

## 面向对象
### 类与对象的变量查找顺序
当访问对象的变量时，首先在对象的实例变量中查找；若未找到则去对象的类变量中查找；若还未找到则去父类中查找。
*注：在类的外部，通过方法\_\_dict\_\_来查看类和对象的所有变量，它是字典类型。*

### 在实例方法中访问实例变量和类变量
* 访问实例变量：`self.变量名`
* 访问类变量：`self.__class__.变量名` 或 `类名.变量名`

### 变量或方法变成私有的方法
在变量名或方法名前加双下划綫：`__`。
*注：在变量名或方法名前后都加上双下划线会导致重新变成公有。*
#### 在外部可以为双下划线开头的变量赋值原因
Python作为动态语言可以通过 `.` 的方式添加新的实例变量，这里相当于新添加了一个变量，原私有变量不变。
#### Python实现私有变量或方法的原理
将定义的私有变量改名为 `类名（单下划线开头） + 私有变量名（双下划綫开头）`，可通过\_\_dict\_\_验证。

### 子类方法调用父类方法
调用父类方法的格式为：
```python
super(子类名, self).父类方法
```
可调用的父类方法既包括构造函数，也包括普通方法。

*当子类的方法和父类方法同名时，子类对象优先调用子类的方法，可以通过super强制调用父类方法。*

## Python高级语法
### 枚举
#### 枚举本质是一个类
python中所有枚举类型都是enum模块下Enum类的子类。如：
```python
from enum import Enum
class VIP(Enum):
    YELLOW = 1
    GREEN = 2
    BLACK = 3
    RED = 4
```
枚举中的标识最好全部使用大写。
*注：枚举的意义重在标签而不在于数值，使用 `print(VIP.YELLOW)` 打印结果是 `VIP.YELLOW` 而不是1，这也符合枚举的意义。*

#### 枚举相比普通类的优势
用字典类型和类表示枚举值的缺点：
> * 可变。
> * 没有防止相同标签的功能。

#### 枚举类型、枚举名称和枚举值
* `print(VIP.GREEN)` 返回 `VIP.GREEN`，是枚举类型。
* `print(VIP.GREEN.name)` 返回 `GREEN`，是str类型。
* `print(VIP.GREEN.value)` 返回 `2`，是对应的枚举值类型。

#### 枚举的比较运算
* 枚举类型之间可以进行等值比较（==），但直接和数值比较会返回False，如 `VIP.GREEN == 2` 返回False，应使用 `VIP.GREEN == VIP(2)` 才能得到正确结果。
* 枚举类型之间不支持大小比较操作符（>, <）。
* 枚举类型可以进行身份比较（is），如 `VIP.GREEN is VIP.GREEN` 返回True。
* 不同枚举类中的枚举类型进行比较都会返回False。

#### 枚举的注意事项
* 同一个枚举下不能有相同标签。
* 同一个枚举下不同标签可以有相同数值，第二个标签可以看做是第一个标签的别名（alias）。
* 枚举进行for in循环遍历时，别名不会被打印出来。
* 若要把包括别名的所有成员都打印出来，应使用内置变量\_\_members\_\_，方法为 `枚举名.__members__.items()`，得到的结果是一个元祖。若只是想要标签名称，方法为 `枚举名.__members__`。
* IntEnum：枚举类型每个数值都必须是int类型。
* Enum：不会对枚举类型的数值有类型的限制。
* unique：一个装饰器，可以限制不同的枚举类型不能赋相同的数值。

### 闭包
python中一切皆对象，函数也是对象。
python中的函数不仅可以赋值给变量，还可以作为另外一个函数的参数传递，也可以作为另外一个函数的返回结果。
#### 什么是闭包
闭包跟变量作用域有密切关系，`闭包 = 函数 + 环境变量`，即：函数会绑定在与它所在相同环境的环境变量上（函数与环境变量在同一级作用域）。
```python
f.__closure__ // 返回环境变量，此时的环境变量为一个对象
f.__closure__[0].cell_contents // 返回环境变量的值
```
#### 闭包的意义
保存现场，保存了函数所需要的环境变量，使函数不被外部变量所影响。

### 匿名函数
匿名函数需要使用 `lambda` 表达式，`lambda` 表达式格式：
```python
lambda parameter_list: expression
```
*注：此处的expression只能是简单的表达式，而不能实现像函数内部的代码块。*

### 装饰器
装饰器所要解决的问题：在不修改原始代码逻辑的情况下，增加函数的功能（即：对修改是封闭的，对扩展是开放的）。

语法糖：这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。

装饰器具有通用性，不跟特定的函数绑定，使用可变参数 `*args` 和关键字可变参数 `**kw`，支持不同参数的函数，具体如下所示：
```python
def decorator(func):
    def wrapper(*args, **kw):
        print('start func')
        func(*args, **kw)
    return wrapper
```

## Pythonic与Python杂记
### 字典映射代替switch case语句
由于python中不存在 `switch` 语句，而使用 `if else` 语句替代的代码结构不够清晰，因此这里选择使用字典映射来替代 `switch case` 语句。
#### value值为基本类型
```python
day = 6
switcher = {
    0 : 'Sunday',
    1 : 'Monday',
    2 : 'Tuesday'
}
day_name = switcher.get(day, 'Unknow')
```
*这里通过dict的get方法中第二个参数模拟switch语句中的default。*
#### value值为函数
```python
day = 6
def get_sunday():
    return 'Sunday'
def get_monday():
    return 'Monday'
def get_tuesday():
    return 'Tuesday'
def get_default():
    return 'Unknow'
switcher = {
    0 : get_sunday,
    1 : get_monday,
    2 : get_tuesday
}
day_name = switcher.get(day, get_default)()
```
*由于get方法返回的是函数类型，所以这里使用()来调用。*